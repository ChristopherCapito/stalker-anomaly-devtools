--[[
=======================================================================================
    DevTools ImGui Panel - Standalone Debug UI for S.T.A.L.K.E.R. Anomaly
    
    Self-contained ImGui window providing:
    - Module browser: Discover and select ANY Lua module to profile
    - Performance profiler: Live function timing statistics
    - Log viewer: Filtered, paginated log display
    
    No dependencies on any other mod - works out of the box.
    Auto-registers with Anomaly's ImGui system on game start.
=======================================================================================
--]]

local imgui_ready = false
local warned = false

local init_ui -- forward declaration (so try_init captures LOCAL, not global)


local function has_groups()
	if not ImGui or not ImGui.Groups then
		return false
	end

	-- We don't just need Groups to exist; we need the specific API we call:
	if type(ImGui.Groups.Add) ~= "function" then
		return false
	end
	if not ImGui.Groups.MenuBar or type(ImGui.Groups.MenuBar.Widget) ~= "function" then
		return false
	end
	if not ImGui.Groups.Main or type(ImGui.Groups.Main.Widget) ~= "function" then
		return false
	end

	return true
end

local function safe_register(cb_name, fn)
    if not RegisterScriptCallback then return false end
    local ok, err = pcall(RegisterScriptCallback, cb_name, fn)
    if not ok then
		if DEVTOOLS_VERBOSE then
			printf("[DEVTOOLS] RegisterScriptCallback(%s) failed: %s", tostring(cb_name), tostring(err))
		end
        return false
    end
    return true
end


local function try_init()
	if imgui_ready then
		return true
	end
	if not has_groups() then
		if not warned then
			if DEVTOOLS_VERBOSE then
				printf("[DEVTOOLS] ImGui.Groups not ready - deferring devtools_imgui init")
			end
			warned = true
		end
		return false
	end
	if type(init_ui) ~= "function" then
		-- Init function not defined yet; defer until file finishes loading
		return false
	end
	init_ui()
	imgui_ready = true
	if DEVTOOLS_VERBOSE then
		printf("[DEVTOOLS] devtools_imgui initialized")
	end
	return true
end

safe_register("on_game_start", function()
    try_init()
end)

safe_register("actor_on_update", function()
    if not imgui_ready then
        try_init()
    end
end)

-- ============================================================================
-- WINDOW STATE
-- ============================================================================

local show_profiler_window = false
local show_logs_window = false

-- ============================================================================
-- PROFILER TAB STATE
-- ============================================================================

local hide_fast_functions = false
local sort_column = 3 -- Default: Avg (ms)
local sort_ascending = false -- Descending (slowest first)
local max_visible_rows = 100 -- Limits rows shown for performance (0 = unlimited)
local show_calls = true
local show_avg = true
local show_median = true
local show_min = false
local show_max = false
local show_total = false

local sync_module_colors
local get_module_color_by_name
local minimal_mode = false -- Hide stats table entirely (for flamegraph collection)
-- Rewrap controls
local auto_rewrap_enabled = false
local rewrap_interval_ms = 1000
local last_rewrap_tg = 0

-- Module browser state
local available_modules = {}
local last_module_scan = 0
local MODULE_SCAN_INTERVAL = 5000 -- Rescan every 5 seconds
local module_search_text = "" -- Search filter for module browser

-- Stats cache for performance (throttles table rebuilding)
local cached_stats_display = {}
local cached_total_time = 0
local cached_total_calls = 0
local cached_total_names = 0
local last_stats_update = 0
local STATS_UPDATE_INTERVAL = 150 -- Update every 150ms (roughly 6-7 FPS for stats)
local cached_sort_column = 3
local cached_sort_ascending = false
local cached_hide_fast = false
local cached_show_calls = true
local cached_show_avg = true
local cached_show_median = true
local cached_show_min = false
local cached_show_max = false
local cached_show_total = false

-- Presets state
local preset_name_input = ""
local show_preset_popup = false

-- CSV export state
local last_csv_export_path = nil
local last_csv_export_time = 0
local CSV_EXPORT_MESSAGE_DURATION = 5000 -- Show message for 5 seconds

-- Flamegraph export state
local last_flamegraph_export_path = nil
local last_flamegraph_export_time = 0

-- Timed profiling state
local timed_profiling_enabled = false
local profiling_duration_sec = 10 -- Default 10 seconds
local profiling_duration_text = "10" -- Text input buffer
local profiling_start_time = 0

-- ============================================================================
-- PRE-COMPUTED COLORS (performance optimization - avoids fcolor() allocations)
-- ============================================================================

-- Timing colors (for Avg/Max columns)
local TIMING_COLOR_GREEN = fcolor():set(0.4, 1, 0.4, 1)
local TIMING_COLOR_YELLOW = fcolor():set(1, 1, 0.4, 1)
local TIMING_COLOR_ORANGE = fcolor():set(1, 0.7, 0.3, 1)
local TIMING_COLOR_RED = fcolor():set(1, 0.4, 0.4, 1)

-- Module palette colors
local MODULE_PALETTE = {
	fcolor():set(0.5, 0.8, 1, 1), -- Light blue
	fcolor():set(1, 0.8, 0.5, 1), -- Orange
	fcolor():set(0.5, 1, 0.5, 1), -- Green
	fcolor():set(1, 0.5, 0.8, 1), -- Pink
	fcolor():set(0.8, 0.8, 0.5, 1), -- Yellow
	fcolor():set(0.8, 0.5, 1, 1), -- Purple
	fcolor():set(0.5, 1, 0.8, 1), -- Cyan
	fcolor():set(1, 0.6, 0.6, 1), -- Salmon
}

-- Default/utility colors
local COLOR_WHITE = fcolor():set(1, 1, 1, 1)
local COLOR_GRAY = fcolor():set(0.5, 0.5, 0.5, 1)

-- ============================================================================
-- FORMAT HELPERS
-- ============================================================================

-- Compact number formatting (reduces string allocations)
local function format_compact(ms)
	if ms >= 100 then
		return string.format("%.0f", ms)
	elseif ms >= 10 then
		return string.format("%.1f", ms)
	else
		return string.format("%.2f", ms)
	end
end

-- ============================================================================
-- LOGGING TAB STATE
-- ============================================================================

local selected_severity_index = 1 -- 1=All
local current_page = 1
local ENTRIES_PER_PAGE = 50
local cached_log_entries = {}
local last_log_cache_update = 0
local LOG_CACHE_INTERVAL = 250
local log_search_text = "" -- Search filter for log entries
local category_search_text = "" -- Search filter for categories

-- ============================================================================
-- WINDOW RENDER FUNCTIONS
-- ============================================================================

function render_profiler_window()
	ImGui.SetNextWindowSize(vector2(800, 600), ImGuiCond.FirstUseEver)

	local expanded, visible = ImGui.Begin("DevTools - Profiler", show_profiler_window, ImGuiWindowFlags.None)
	show_profiler_window = visible

	if expanded then
		render_profiler_tab()
	end

	ImGui.End()
end

function render_logs_window()
	ImGui.SetNextWindowSize(vector2(900, 500), ImGuiCond.FirstUseEver)

	local expanded, visible = ImGui.Begin("DevTools - Logs", show_logs_window, ImGuiWindowFlags.None)
	show_logs_window = visible

	if expanded then
		render_logging_tab()
	end

	ImGui.End()
end

-- ============================================================================
-- PROFILER TAB
-- ============================================================================

function render_profiler_tab()
	if not devtools_profiler then
		ImGui.TextColored(fcolor():set(1, 0.5, 0.5, 1), "devtools_profiler.script not loaded")
		return
	end

	-- Module browser section (includes presets)
	render_module_browser()

	ImGui.Separator()

	-- Profiling controls
	render_profiling_controls()

	ImGui.Separator()

	-- Stats table
	render_stats_table()
end

function render_module_browser()
	-- Refresh available modules periodically
	local tg = time_global()
	if tg - last_module_scan > MODULE_SCAN_INTERVAL then
		available_modules = devtools_profiler.discover_modules()
		last_module_scan = tg
	end

	-- Collapsible module browser
	if ImGui.CollapsingHeader("Module Browser - Select modules to profile", 0) then
		-- =============== WARNING DISCLAIMER ===============
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(1, 0.5, 0.2, 1))
		ImGui.TextWrapped(
			"WARNING: Selecting too many modules at once can cause stackoverflows. Use moderation when selecting modules."
		)
		ImGui.PopStyleColor(1)
		ImGui.Spacing()

		-- =============== PRESETS SECTION ===============
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.7, 0.9, 1, 1))
		ImGui.Text("Presets:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()

		-- Preset buttons with delete
		local preset_names = devtools_profiler.get_preset_names()
		if #preset_names > 0 then
			for _, name in ipairs(preset_names) do
				-- Load button
				if ImGui.Button(name .. "##preset_load", vector2(0, 0)) then
					devtools_profiler.load_preset(name)
				end
				ImGui.SameLine(0, 2)
				-- Delete button (small X)
				ImGui.PushStyleColor(ImGuiCol.Button, fcolor():set(0.5, 0.2, 0.2, 1))
				ImGui.PushStyleColor(ImGuiCol.ButtonHovered, fcolor():set(0.8, 0.3, 0.3, 1))
				if ImGui.Button("x##del_" .. name, vector2(18, 0)) then
					devtools_profiler.delete_preset(name)
				end
				ImGui.PopStyleColor(2)
				ImGui.SameLine(0, 10)
			end
		else
			ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
			ImGui.Text("(none)")
			ImGui.PopStyleColor(1)
			ImGui.SameLine()
		end

		-- Save preset button
		if ImGui.Button("Save...", vector2(50, 0)) then
			show_preset_popup = true
			preset_name_input = ""
		end

		-- Save preset popup (inline)
		if show_preset_popup then
			ImGui.SameLine()
			ImGui.Text("Name:")
			ImGui.SameLine()
			local new_name, name_changed = ImGui.InputText("##preset_name", preset_name_input, 30)
			if name_changed then
				preset_name_input = new_name
			end
			ImGui.SameLine()
			if ImGui.Button("OK##save_preset", vector2(30, 0)) then
				if preset_name_input ~= "" then
					devtools_profiler.save_preset(preset_name_input)
					show_preset_popup = false
				end
			end
			ImGui.SameLine()
			if ImGui.Button("Cancel##cancel_preset", vector2(50, 0)) then
				show_preset_popup = false
			end
		end

		ImGui.Spacing()

		-- =============== SEARCH SECTION ===============
		ImGui.Text("Search:")
		ImGui.SameLine()
		local new_search, changed = ImGui.InputText("##module_search", module_search_text, 100)
		if changed then
			module_search_text = new_search
		end
		ImGui.SameLine()
		if ImGui.Button("X##clear_search", vector2(20, 0)) then
			module_search_text = ""
		end

		-- Filter modules by search
		local filtered_modules = {}
		local search_lower = string.lower(module_search_text)
		for _, mod_name in ipairs(available_modules) do
			if module_search_text == "" or string.find(string.lower(mod_name), search_lower, 1, true) then
				table.insert(filtered_modules, mod_name)
			end
		end

		ImGui.SameLine(0, 20)
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		if module_search_text ~= "" then
			ImGui.Text(string.format("Showing %d/%d modules", #filtered_modules, #available_modules))
		else
			ImGui.Text(string.format("%d modules found", #available_modules))
		end
		ImGui.PopStyleColor(1)

		ImGui.Spacing()

		-- =============== QUICK ACTIONS ===============
		if ImGui.Button("Refresh", vector2(70, 0)) then
			available_modules = devtools_profiler.discover_modules()
		end
		ImGui.SameLine()
		if ImGui.Button("Clear Selection", vector2(100, 0)) then
			for _, mod_name in ipairs(devtools_profiler.get_registered_modules()) do
				devtools_profiler.unregister_module(mod_name)
			end
		end
		ImGui.SameLine()

		local select_btn_text = (module_search_text == "") and "Select All" or "Select Filtered"

		if ImGui.Button(select_btn_text, vector2(100, 0)) then
			for _, mod_name in ipairs(filtered_modules) do
				if not devtools_profiler.is_module_registered(mod_name) then
					devtools_profiler.register_module(mod_name)
				end
			end
		end

		ImGui.Spacing()

		-- =============== MODULE CHECKBOXES ===============
		local col = 0
		local max_cols = 4

		for _, mod_name in ipairs(filtered_modules) do
			local is_registered = devtools_profiler.is_module_registered(mod_name)
			local is_wrapped = devtools_profiler.is_module_wrapped(mod_name)

			-- Color based on status
			if is_wrapped then
				ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.4, 1, 0.4, 1))
			elseif is_registered then
				ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(1, 1, 0.4, 1))
			end

			local _, new_state = ImGui.Checkbox(mod_name .. "##mod", is_registered)
			if new_state ~= is_registered then
				if new_state then
					devtools_profiler.register_module(mod_name)
				else
					devtools_profiler.unregister_module(mod_name)
				end
			end

			if is_wrapped or is_registered then
				ImGui.PopStyleColor(1)
			end

			col = col + 1
			if col < max_cols then
				ImGui.SameLine(0, 20)
			else
				col = 0
			end
		end

		if col ~= 0 then
			ImGui.Text("") -- End SameLine chain
		end

		-- Legend
		ImGui.Spacing()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text("Legend:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.4, 1, 0.4, 1))
		ImGui.Text("Active")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(1, 1, 0.4, 1))
		ImGui.Text("Registered")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.Text("Available")
	end
end

function render_profiling_controls()
	-- Defensive: profiler can be partially loaded or missing functions
	local profiler_ok = (devtools_profiler ~= nil)

	local is_enabled = false
	if profiler_ok and type(devtools_profiler.is_enabled) == "function" then
		is_enabled = devtools_profiler.is_enabled()
	end

	local wrapped_count = 0
	if profiler_ok and type(devtools_profiler.get_wrapped_function_count) == "function" then
		wrapped_count = devtools_profiler.get_wrapped_function_count()
	end

	local wrapped_modules = {}
	if profiler_ok and type(devtools_profiler.get_wrapped_modules) == "function" then
		wrapped_modules = devtools_profiler.get_wrapped_modules() or {}
	end
	if #wrapped_modules > 0 then
		sync_module_colors(wrapped_modules)
	end

	local registered = {}
	if profiler_ok and type(devtools_profiler.get_registered_modules) == "function" then
		registered = devtools_profiler.get_registered_modules() or {}
	end

	-- If profiler exists but is missing key API, show a non-fatal warning
	if profiler_ok and type(devtools_profiler.is_enabled) ~= "function" then
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(1, 0.5, 0.5, 1))
		ImGui.Text("Profiler API incomplete: is_enabled() missing")
		ImGui.PopStyleColor(1)

		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.6, 0.6, 0.6, 1))
		ImGui.TextWrapped(
			"The UI is running, but devtools_profiler.script did not expose is_enabled/enable/disable correctly."
		)
		ImGui.PopStyleColor(1)

		ImGui.Spacing()
	end

	-- Status
	if is_enabled then
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.4, 1, 0.4, 1))
		ImGui.Text("PROFILING ACTIVE")
		ImGui.PopStyleColor(1)
		ImGui.SameLine(0, 10)
		ImGui.Text(string.format("(%d functions in %d modules)", wrapped_count, #wrapped_modules))
	else
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.6, 0.6, 0.6, 1))
		ImGui.Text("PROFILING INACTIVE")
		ImGui.PopStyleColor(1)
		ImGui.SameLine(0, 10)
		ImGui.Text(string.format("(%d modules selected)", #registered))
	end

	ImGui.Spacing()

	-- Enable/Disable button
	if is_enabled then
		if ImGui.Button("Stop Profiling", vector2(120, 0)) then
			if profiler_ok and type(devtools_profiler.disable) == "function" then
				devtools_profiler.disable()
			end
			timed_profiling_enabled = false
		end

		-- Show timer countdown if timed profiling is active
		if timed_profiling_enabled then
			ImGui.SameLine()
			local elapsed = (time_global() - profiling_start_time) / 1000
			local remaining = math.max(0, profiling_duration_sec - elapsed)
			ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(1, 0.8, 0.3, 1))
			ImGui.Text(string.format("Auto-stop in %.1fs", remaining))
			ImGui.PopStyleColor(1)
		end
	else
		local can_start = (#registered > 0) and profiler_ok and (type(devtools_profiler.enable) == "function")
		if not can_start then
			ImGui.PushStyleColor(ImGuiCol.Button, fcolor():set(0.3, 0.3, 0.3, 1))
		end

		if ImGui.Button("Start Profiling", vector2(120, 0)) then
			if can_start then
				devtools_profiler.enable()
				-- Start timer if timed mode is enabled
				if timed_profiling_enabled then
					profiling_start_time = time_global()
					printf(
						"[DEVTOOLS] Timed profiling started - will stop in " .. tostring(profiling_duration_sec) .. "s"
					)
				end
			end
		end

		if not can_start then
			ImGui.PopStyleColor(1)
			ImGui.SameLine()
			ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(1, 0.5, 0.5, 1))

			if not profiler_ok then
				ImGui.Text("Profiler not loaded")
			elseif #registered == 0 then
				ImGui.Text("Select modules above first")
			elseif type(devtools_profiler.enable) ~= "function" then
				ImGui.Text("Profiler enable() missing")
			else
				ImGui.Text("Cannot start profiling")
			end

			ImGui.PopStyleColor(1)
		end

		-- Timed profiling controls (only show when profiler is stopped)
		ImGui.SameLine(0, 20)
		local _, new_timed = ImGui.Checkbox("Timed##timed_profiling", timed_profiling_enabled)
		if new_timed ~= timed_profiling_enabled then
			timed_profiling_enabled = new_timed
		end

		if timed_profiling_enabled then
			ImGui.SameLine()
			local new_text, text_changed = ImGui.InputText("sec##duration", profiling_duration_text, 5)
			if text_changed then
				profiling_duration_text = new_text
				-- Parse and sanitize to number
				local num = tonumber(new_text)
				if num then
					profiling_duration_sec = math.max(1, math.min(300, math.floor(num)))
				end
			end
		end
	end

	ImGui.SameLine(0, 20)

	if ImGui.Button("Reset Stats", vector2(100, 0)) then
		if profiler_ok and type(devtools_profiler.reset_all) == "function" then
			devtools_profiler.reset_all()
		end
	end

	ImGui.SameLine()

	if ImGui.Button("Export CSV", vector2(100, 0)) then
		if profiler_ok and type(devtools_profiler.export_to_csv) == "function" then
			local success, path = devtools_profiler.export_to_csv()
			if success then
				last_csv_export_path = path
				last_csv_export_time = time_global()
				if DEVTOOLS_VERBOSE then
					printf("[DEVTOOLS] CSV exported successfully to: " .. tostring(path))
				end
			else
				last_csv_export_path = nil
				last_csv_export_time = 0
			end
		else
			last_csv_export_path = nil
			last_csv_export_time = 0
		end
	end

	ImGui.Spacing()
	ImGui.Separator()
	ImGui.Spacing()

	-- Rewrap controls
	if profiler_ok and type(devtools_profiler.rewrap_registered_modules) == "function" then
		if ImGui.Button("Re-scan Now", vector2(100, 0)) then
			local added = devtools_profiler.rewrap_registered_modules()
			if added and added > 0 then
				if DEVTOOLS_VERBOSE then
					printf("[DEVTOOLS] Re-scan wrapped %d new functions", added)
				end
			else
				if DEVTOOLS_VERBOSE then
					printf("[DEVTOOLS] Re-scan found no new functions to wrap")
				end
			end
		end
		ImGui.SameLine(0, 20)
		local _, new_auto = ImGui.Checkbox("Auto rewrap", auto_rewrap_enabled)
		if new_auto ~= auto_rewrap_enabled then
			auto_rewrap_enabled = new_auto
			last_rewrap_tg = 0
		end
		ImGui.SameLine()
		ImGui.Text("Interval (ms):")
		ImGui.SameLine()
		local new_text, changed = ImGui.InputText("##rewrap_interval", tostring(rewrap_interval_ms), 8)
		if changed then
			local num = tonumber(new_text)
			if num and num >= 100 and num <= 10000 then
				rewrap_interval_ms = math.floor(num)
			end
		end
		ImGui.Spacing()
	end

	ImGui.Text("Flamegraph Export:")
	ImGui.SameLine()

	local fg_enabled = false
	if profiler_ok and type(devtools_profiler.is_flamegraph_enabled) == "function" then
		fg_enabled = devtools_profiler.is_flamegraph_enabled()
	end

	local _, new_fg_enabled = ImGui.Checkbox("Collect Data##flamegraph", fg_enabled)
	if new_fg_enabled ~= fg_enabled then
		if profiler_ok then
			if new_fg_enabled and type(devtools_profiler.enable_flamegraph) == "function" then
				devtools_profiler.enable_flamegraph()
			elseif (not new_fg_enabled) and type(devtools_profiler.disable_flamegraph) == "function" then
				devtools_profiler.disable_flamegraph()
			end
		end
	end

	ImGui.SameLine()

	local sample_count = 0
	if profiler_ok and type(devtools_profiler.get_flamegraph_sample_count) == "function" then
		sample_count = devtools_profiler.get_flamegraph_sample_count() or 0
	end

	local has_flamegraph_data = (sample_count > 0)
	local can_export_flamegraph = fg_enabled or has_flamegraph_data

	if not can_export_flamegraph then
		ImGui.PushStyleColor(ImGuiCol.Button, fcolor():set(0.3, 0.3, 0.3, 1))
	end

	if ImGui.Button("Export Flamegraph", vector2(130, 0)) then
		if can_export_flamegraph and profiler_ok and type(devtools_profiler.export_flamegraph) == "function" then
			local success, path = devtools_profiler.export_flamegraph()
			if success then
				last_flamegraph_export_path = path
				last_flamegraph_export_time = time_global()
				if DEVTOOLS_VERBOSE then
					printf("[DEVTOOLS] Flamegraph exported successfully to: " .. tostring(path))
				end
			else
				last_flamegraph_export_path = nil
				last_flamegraph_export_time = 0
			end
		end
	end

	if not can_export_flamegraph then
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text("(enable collection first)")
		ImGui.PopStyleColor(1)
	end

	ImGui.Spacing()

	-- Auto-start checkbox
	local auto_start = false
	if profiler_ok and type(devtools_profiler.preset_exists) == "function" then
		auto_start = devtools_profiler.preset_exists("_AUTOLOAD_")
	end

	local _, new_auto_start = ImGui.Checkbox("Profile on Load", auto_start)

	if new_auto_start ~= auto_start then
		if profiler_ok then
			if new_auto_start then
				if type(devtools_profiler.save_preset) == "function" then
					devtools_profiler.save_preset("_AUTOLOAD_")
				end
				local fg_state = false
				if type(devtools_profiler.is_flamegraph_enabled) == "function" then
					fg_state = devtools_profiler.is_flamegraph_enabled()
				end
				if fg_state then
					if DEVTOOLS_VERBOSE then
						printf("[DEVTOOLS] Auto-start ENABLED (saved current selection + flamegraph enabled)")
					end
				else
					if DEVTOOLS_VERBOSE then
						printf("[DEVTOOLS] Auto-start ENABLED (saved current selection)")
					end
				end
			else
				if type(devtools_profiler.delete_preset) == "function" then
					devtools_profiler.delete_preset("_AUTOLOAD_")
				end
				if DEVTOOLS_VERBOSE then
					printf("[DEVTOOLS] Auto-start DISABLED")
				end
			end
		end
	end

	ImGui.SameLine()

	local _, new_hide = ImGui.Checkbox("Hide fast (<0.01ms)", hide_fast_functions)

	-- Performance controls
	ImGui.Spacing()
	ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.7, 0.7, 0.7, 1))
	ImGui.Text("Display:")
	ImGui.PopStyleColor(1)
	ImGui.SameLine()

	-- Row limit control
	ImGui.Text("Max rows:")
	ImGui.SameLine()
	if ImGui.Button("All##rows", vector2(30, 0)) then
		max_visible_rows = 0
	end
	ImGui.SameLine(0, 2)
	if ImGui.Button("50##rows", vector2(25, 0)) then
		max_visible_rows = 50
	end
	ImGui.SameLine(0, 2)
	if ImGui.Button("100##rows", vector2(30, 0)) then
		max_visible_rows = 100
	end
	ImGui.SameLine(0, 2)
	if ImGui.Button("200##rows", vector2(30, 0)) then
		max_visible_rows = 200
	end

	ImGui.SameLine(0, 15)
	local _, new_minimal = ImGui.Checkbox("Minimal mode", minimal_mode)
	if new_minimal ~= minimal_mode then
		minimal_mode = new_minimal
	end

	ImGui.Spacing()
	ImGui.Text("Columns:")
	ImGui.SameLine()
	local _, new_calls = ImGui.Checkbox("Calls", show_calls)
	if new_calls ~= show_calls then
		show_calls = new_calls
	end
	ImGui.SameLine()
	local _, new_avg = ImGui.Checkbox("Avg", show_avg)
	if new_avg ~= show_avg then
		show_avg = new_avg
	end
	ImGui.SameLine()
	local _, new_median = ImGui.Checkbox("Median", show_median)
	if new_median ~= show_median then
		show_median = new_median
	end
	ImGui.SameLine()
	local _, new_min = ImGui.Checkbox("Min", show_min)
	if new_min ~= show_min then
		show_min = new_min
	end
	ImGui.SameLine()
	local _, new_max = ImGui.Checkbox("Max", show_max)
	if new_max ~= show_max then
		show_max = new_max
	end
	ImGui.SameLine()
	local _, new_total = ImGui.Checkbox("Total", show_total)
	if new_total ~= show_total then
		show_total = new_total
	end

	-- CSV export path display
	if last_csv_export_path and (time_global() - last_csv_export_time) < CSV_EXPORT_MESSAGE_DURATION then
		ImGui.Spacing()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.4, 1, 0.4, 1))
		ImGui.Text("CSV exported to:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.7, 0.7, 0.7, 1))
		ImGui.TextWrapped(last_csv_export_path)
		ImGui.PopStyleColor(1)
	elseif last_csv_export_path then
		ImGui.Spacing()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text("Last export:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.6, 0.6, 0.6, 1))
		ImGui.TextWrapped(last_csv_export_path)
		ImGui.PopStyleColor(1)
	end

	if last_flamegraph_export_path and (time_global() - last_flamegraph_export_time) < CSV_EXPORT_MESSAGE_DURATION then
		ImGui.Spacing()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.4, 1, 0.4, 1))
		ImGui.Text("Flamegraph exported to:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.7, 0.7, 0.7, 1))
		ImGui.TextWrapped(last_flamegraph_export_path)
		ImGui.PopStyleColor(1)
	elseif last_flamegraph_export_path then
		ImGui.Spacing()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text("Last flamegraph export:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.6, 0.6, 0.6, 1))
		ImGui.TextWrapped(last_flamegraph_export_path)
		ImGui.PopStyleColor(1)
	end

	if new_hide ~= hide_fast_functions then
		hide_fast_functions = new_hide
	end

	-- Show wrapped modules
	if is_enabled and #wrapped_modules > 0 then
		ImGui.Spacing()
		ImGui.Text("Active:")
		ImGui.SameLine()
		for i, mod_name in ipairs(wrapped_modules) do
			if i > 1 then
				ImGui.SameLine(0, 5)
			end
			ImGui.PushStyleColor(ImGuiCol.Text, get_module_color_by_name(mod_name))
			ImGui.Text(mod_name)
			ImGui.PopStyleColor(1)
		end
	end
end

function render_stats_table()
	local names = devtools_profiler.get_tracked_functions()

	if #names == 0 then
		ImGui.TextColored(fcolor():set(0.5, 0.5, 0.5, 1), "No data yet. Select modules and start profiling.")
		return
	end

	-- Throttle stats rebuilding for performance
	local tg = time_global()
	local display_list
	local total_time
	local total_calls

	-- Force refresh if sort/filter settings changed
	local settings_changed = (sort_column ~= cached_sort_column)
		or (sort_ascending ~= cached_sort_ascending)
		or (hide_fast_functions ~= cached_hide_fast)
		or (show_calls ~= cached_show_calls)
		or (show_avg ~= cached_show_avg)
		or (show_median ~= cached_show_median)
		or (show_min ~= cached_show_min)
		or (show_max ~= cached_show_max)
		or (show_total ~= cached_show_total)

	if settings_changed or (tg - last_stats_update > STATS_UPDATE_INTERVAL) then
		-- Rebuild stats (expensive operation)
		local all_stats = devtools_profiler.get_all_stats()
		display_list = {}
		total_time = 0
		total_calls = 0

		for _, name in ipairs(names) do
			local s = all_stats[name]
			if s then
				local include = true
				if hide_fast_functions and s.avg_ms < 0.01 then
					include = false
				end
				if include then
					table.insert(display_list, { name = name, stats = s })
					total_time = total_time + s.total_ms
					total_calls = total_calls + s.call_count
				end
			end
		end

		-- Sort (dynamic by visible columns)
		local columns = {
			{ name = "Function", width = 260, key = "name" },
		}
		if show_calls then table.insert(columns, { name = "Calls", width = 55, key = "call_count" }) end
		if show_avg then table.insert(columns, { name = "Avg (ms)", width = 65, key = "avg_ms" }) end
		if show_median then table.insert(columns, { name = "Median (ms)", width = 75, key = "median_ms" }) end
		if show_min then table.insert(columns, { name = "Min (ms)", width = 65, key = "min_ms" }) end
		if show_max then table.insert(columns, { name = "Max (ms)", width = 65, key = "max_ms" }) end
		if show_total then table.insert(columns, { name = "Total (ms)", width = 75, key = "total_ms" }) end

		if sort_column > #columns then
			sort_column = 1
			sort_ascending = true
		end
		local sort_key = columns[sort_column].key

		table.sort(display_list, function(a, b)
			local val_a, val_b
			if sort_key == "name" then
				val_a, val_b = a.name, b.name
			else
				val_a, val_b = a.stats[sort_key], b.stats[sort_key]
			end
			if sort_ascending then
				return val_a < val_b
			else
				return val_a > val_b
			end
		end)

		-- Cache results
		cached_stats_display = display_list
		cached_total_time = total_time
		cached_total_calls = total_calls
		cached_total_names = #names
		cached_sort_column = sort_column
		cached_sort_ascending = sort_ascending
		cached_hide_fast = hide_fast_functions
		cached_show_calls = show_calls
		cached_show_avg = show_avg
		cached_show_median = show_median
		cached_show_min = show_min
		cached_show_max = show_max
		cached_show_total = show_total
		last_stats_update = tg
	else
		-- Use cached data
		display_list = cached_stats_display
		total_time = cached_total_time
		total_calls = cached_total_calls
	end

	-- Apply row limit for rendering
	local render_count = #display_list
	if max_visible_rows > 0 and render_count > max_visible_rows then
		render_count = max_visible_rows
	end

	-- Summary
	local limit_text = ""
	if max_visible_rows > 0 and #display_list > max_visible_rows then
		limit_text = string.format(" (showing top %d)", max_visible_rows)
	end
	ImGui.Text(
		string.format(
			"Showing %d/%d functions%s | Total: %.1fms across %d calls",
			#display_list,
			cached_total_names,
			limit_text,
			total_time,
			total_calls
		)
	)
	ImGui.Spacing()

	-- Minimal mode: skip table rendering entirely
	if minimal_mode then
		ImGui.PushStyleColor(ImGuiCol.Text, COLOR_GRAY)
		ImGui.Text("(Minimal mode - table hidden for performance)")
		ImGui.PopStyleColor(1)
		return
	end

	-- Column definitions (dynamic)
	local columns = {
		{ name = "Function", width = 260 },
	}
	if show_calls then table.insert(columns, { name = "Calls", width = 55 }) end
	if show_avg then table.insert(columns, { name = "Avg (ms)", width = 65 }) end
	if show_median then table.insert(columns, { name = "Median (ms)", width = 75 }) end
	if show_min then table.insert(columns, { name = "Min (ms)", width = 65 }) end
	if show_max then table.insert(columns, { name = "Max (ms)", width = 65 }) end
	if show_total then table.insert(columns, { name = "Total (ms)", width = 75 }) end

	local col_count = #columns

	-- Table
	if ImGui.BeginTable("DevToolsStats", col_count, 4, vector2(0, 0), 0) then
		for _, col in ipairs(columns) do
			ImGui.TableSetupColumn(col.name, 0, col.width, 0)
		end

		-- Header row with sorting
		ImGui.TableNextRow()
		for i, col in ipairs(columns) do
			ImGui.TableNextColumn()
			local label = col.name
			local sort_idx = i
			if sort_column == sort_idx then
				label = label .. (sort_ascending and " ^" or " v")
			end
			if sort_column == sort_idx then
				ImGui.PushStyleColor(ImGuiCol.Button, fcolor():set(0.3, 0.5, 0.8, 1))
			end
			if ImGui.Button(label .. "##col" .. i, vector2(col.width - 8, 0)) then
				if sort_column == sort_idx then
					sort_ascending = not sort_ascending
				else
					sort_column = sort_idx
					sort_ascending = (sort_idx == 1)
				end
			end
			if sort_column == sort_idx then
				ImGui.PopStyleColor(1)
			end
		end

		-- Data rows (limited by max_visible_rows for performance)
		for i = 1, render_count do
			local item = display_list[i]
			if not item then
				break
			end
			local s = item.stats
			ImGui.TableNextRow()

			-- Function name (colored by module)
			ImGui.TableNextColumn()
			ImGui.PushStyleColor(ImGuiCol.Text, get_module_color(item.name))
			ImGui.Text(item.name)
			ImGui.PopStyleColor(1)

			-- Calls
			if show_calls then
				ImGui.TableNextColumn()
				ImGui.Text(tostring(s.call_count))
			end

			-- Avg (colored by timing)
			if show_avg then
				ImGui.TableNextColumn()
				ImGui.PushStyleColor(ImGuiCol.Text, get_timing_color(s.avg_ms))
				ImGui.Text(format_compact(s.avg_ms))
				ImGui.PopStyleColor(1)
			end

			-- Median (colored by timing)
			if show_median then
				ImGui.TableNextColumn()
				ImGui.PushStyleColor(ImGuiCol.Text, get_timing_color(s.median_ms))
				ImGui.Text(format_compact(s.median_ms))
				ImGui.PopStyleColor(1)
			end

			-- Min
			if show_min then
				ImGui.TableNextColumn()
				ImGui.Text(format_compact(s.min_ms))
			end

			-- Max (colored by timing)
			if show_max then
				ImGui.TableNextColumn()
				ImGui.PushStyleColor(ImGuiCol.Text, get_timing_color(s.max_ms))
				ImGui.Text(format_compact(s.max_ms))
				ImGui.PopStyleColor(1)
			end

			-- Total
			if show_total then
				ImGui.TableNextColumn()
				ImGui.Text(format_compact(s.total_ms))
			end
		end

		ImGui.EndTable()
	end
end

-- ============================================================================
-- LOGGING TAB
-- ============================================================================

function render_logging_tab()
	if not devtools_logging then
		ImGui.TextColored(fcolor():set(1, 0.5, 0.5, 1), "devtools_logging.script not loaded")
		return
	end

	-- Update cache
	local tg = time_global()
	if tg - last_log_cache_update > LOG_CACHE_INTERVAL then
		update_log_cache()
		last_log_cache_update = tg
	end

	render_log_controls()
	ImGui.Separator()
	render_log_categories()
	ImGui.Separator()
	render_log_list()
end

function update_log_cache()
	local all_entries = devtools_logging.get_entries()
	cached_log_entries = {}

	local severity_threshold = 1
	if selected_severity_index > 1 then
		local map = { [2] = 1, [3] = 2, [4] = 3, [5] = 4 }
		severity_threshold = map[selected_severity_index] or 1
	end

	local search_lower = string.lower(log_search_text)

	for _, entry in ipairs(all_entries) do
		local include = true
		if entry.severity < severity_threshold then
			include = false
		end
		if include and not devtools_logging.is_category_enabled(entry.category) then
			include = false
		end
		-- Search filter
		if include and log_search_text ~= "" then
			local msg_lower = string.lower(entry.message or "")
			local cat_lower = string.lower(entry.category or "")
			if
				not string.find(msg_lower, search_lower, 1, true)
				and not string.find(cat_lower, search_lower, 1, true)
			then
				include = false
			end
		end
		if include then
			table.insert(cached_log_entries, entry)
		end
	end
end

function render_log_controls()
	local stats = devtools_logging.get_stats()
	local paused = devtools_logging.is_paused()
	local enabled = devtools_logging.is_enabled()

	-- Enable/Pause/Clear
	local _, new_enabled = ImGui.Checkbox("Enabled", enabled)
	if new_enabled ~= enabled then
		devtools_logging.set_enabled(new_enabled)
	end

	ImGui.SameLine()

	local pause_label = paused and "Resume" or "Pause"
	if ImGui.Button(pause_label, vector2(60, 0)) then
		devtools_logging.set_paused(not paused)
	end

	ImGui.SameLine()

	if ImGui.Button("Clear", vector2(50, 0)) then
		devtools_logging.clear()
		cached_log_entries = {}
	end

	ImGui.SameLine()

	local status_color = paused and fcolor():set(1, 1, 0, 1) or fcolor():set(0.5, 1, 0.5, 1)
	ImGui.PushStyleColor(ImGuiCol.Text, status_color)
	ImGui.Text(string.format("  %d/%d entries (total: %d)", #cached_log_entries, stats.count, stats.total_logged))
	ImGui.PopStyleColor(1)

	-- Search filter
	ImGui.Text("Search:")
	ImGui.SameLine()
	local new_search, changed = ImGui.InputText("##log_search", log_search_text, 100)
	if changed then
		log_search_text = new_search
		last_log_cache_update = 0 -- Force cache refresh
		current_page = 1
	end
	ImGui.SameLine()
	if ImGui.Button("X##clear_log_search", vector2(20, 0)) then
		log_search_text = ""
		last_log_cache_update = 0
		current_page = 1
	end
	if log_search_text ~= "" then
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text(string.format("(filtering by '%s')", log_search_text))
		ImGui.PopStyleColor(1)
	end

	-- Severity filter
	ImGui.Text("Severity:")
	ImGui.SameLine()
	local severity_options = { "All", "DEBUG", "INFO", "WARN", "ERROR" }
	for i, sev_name in ipairs(severity_options) do
		local is_selected = (selected_severity_index == i)
		if is_selected then
			ImGui.PushStyleColor(ImGuiCol.Button, fcolor():set(0.3, 0.5, 0.8, 1))
		end
		if ImGui.Button(sev_name .. "##sev", vector2(0, 0)) then
			selected_severity_index = i
			last_log_cache_update = 0
			current_page = 1
		end
		if is_selected then
			ImGui.PopStyleColor(1)
		end
		if i < #severity_options then
			ImGui.SameLine()
		end
	end

	-- Output options
	local echo = devtools_logging.is_echo_to_console()
	local _, new_echo = ImGui.Checkbox("Echo to console", echo)
	if new_echo ~= echo then
		devtools_logging.set_echo_to_console(new_echo)
	end

	ImGui.SameLine()

	local file = devtools_logging.is_write_to_file()
	local _, new_file = ImGui.Checkbox("Write to file", file)
	if new_file ~= file then
		devtools_logging.set_write_to_file(new_file)
	end

	if file then
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text("(" .. devtools_logging.get_file_path() .. ")")
		ImGui.PopStyleColor(1)
	end
end

function render_log_categories()
	-- Collapsible category browser
	if ImGui.CollapsingHeader("Category Browser - Filter log categories", 0) then
		local categories = devtools_logging.get_categories()

		-- Search input
		ImGui.Text("Search:")
		ImGui.SameLine()
		local new_cat_search, cat_changed = ImGui.InputText("##cat_search", category_search_text, 50)
		if cat_changed then
			category_search_text = new_cat_search
		end
		ImGui.SameLine()
		if ImGui.Button("X##clear_cat_search", vector2(20, 0)) then
			category_search_text = ""
		end

		-- Filter categories by search
		local filtered_categories = {}
		local search_lower = string.lower(category_search_text)
		for _, cat in ipairs(categories) do
			if category_search_text == "" or string.find(string.lower(cat), search_lower, 1, true) then
				table.insert(filtered_categories, cat)
			end
		end

		ImGui.SameLine(0, 20)
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		if category_search_text ~= "" then
			ImGui.Text(string.format("Showing %d/%d categories", #filtered_categories, #categories))
		else
			ImGui.Text(string.format("%d categories", #categories))
		end
		ImGui.PopStyleColor(1)

		ImGui.Spacing()

		-- Quick actions
		if ImGui.Button("All On", vector2(60, 0)) then
			devtools_logging.set_all_categories_enabled(true)
			last_log_cache_update = 0
			current_page = 1
		end
		ImGui.SameLine()
		if ImGui.Button("All Off", vector2(60, 0)) then
			devtools_logging.set_all_categories_enabled(false)
			last_log_cache_update = 0
			current_page = 1
		end
		ImGui.SameLine()
		if ImGui.Button("Enable Filtered", vector2(100, 0)) then
			for _, cat in ipairs(filtered_categories) do
				devtools_logging.set_category_enabled(cat, true)
			end
			last_log_cache_update = 0
			current_page = 1
		end
		ImGui.SameLine()
		if ImGui.Button("Disable Filtered", vector2(100, 0)) then
			for _, cat in ipairs(filtered_categories) do
				devtools_logging.set_category_enabled(cat, false)
			end
			last_log_cache_update = 0
			current_page = 1
		end

		ImGui.Spacing()

		-- Category checkboxes in columns
		local col = 0
		local max_cols = 5

		for _, cat in ipairs(filtered_categories) do
			local cat_enabled = devtools_logging.is_category_enabled(cat)
			local color = devtools_logging.get_category_color(cat)

			-- Color based on category color and enabled state
			if color then
				if cat_enabled then
					ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(color[1] / 255, color[2] / 255, color[3] / 255, 1))
				else
					-- Dimmed color when disabled
					ImGui.PushStyleColor(
						ImGuiCol.Text,
						fcolor():set(color[1] / 255 * 0.5, color[2] / 255 * 0.5, color[3] / 255 * 0.5, 1)
					)
				end
			end

			local _, new_enabled = ImGui.Checkbox(cat .. "##cat", cat_enabled)
			if new_enabled ~= cat_enabled then
				devtools_logging.set_category_enabled(cat, new_enabled)
				last_log_cache_update = 0
				current_page = 1
			end

			if color then
				ImGui.PopStyleColor(1)
			end

			col = col + 1
			if col < max_cols then
				ImGui.SameLine(0, 15)
			else
				col = 0
			end
		end

		if col ~= 0 then
			ImGui.Text("") -- End SameLine chain
		end

		-- Legend
		ImGui.Spacing()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
		ImGui.Text("Legend:")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.4, 1, 0.4, 1))
		ImGui.Text("Enabled")
		ImGui.PopStyleColor(1)
		ImGui.SameLine()
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.3, 0.3, 0.3, 1))
		ImGui.Text("Disabled")
		ImGui.PopStyleColor(1)
	end
end

function render_log_list()
	local total = #cached_log_entries
	local total_pages = math.max(1, math.ceil(total / ENTRIES_PER_PAGE))

	if current_page > total_pages then
		current_page = total_pages
	end
	if current_page < 1 then
		current_page = 1
	end

	local page_start = total - ((current_page - 1) * ENTRIES_PER_PAGE)
	local page_end = math.max(1, page_start - ENTRIES_PER_PAGE + 1)

	-- Pagination
	if ImGui.Button("|<", vector2(25, 0)) then
		current_page = 1
	end
	ImGui.SameLine()
	if ImGui.Button("<", vector2(25, 0)) then
		current_page = math.max(1, current_page - 1)
	end
	ImGui.SameLine()
	ImGui.Text(string.format("Page %d/%d", current_page, total_pages))
	ImGui.SameLine()
	if ImGui.Button(">", vector2(25, 0)) then
		current_page = math.min(total_pages, current_page + 1)
	end
	ImGui.SameLine()
	if ImGui.Button(">|", vector2(25, 0)) then
		current_page = total_pages
	end

	if total == 0 then
		ImGui.TextColored(fcolor():set(0.5, 0.5, 0.5, 1), "No log entries")
		return
	end

	ImGui.Text(string.format("Showing %d-%d of %d", page_end, page_start, total))
	ImGui.Separator()

	-- Entries
	for i = page_start, page_end, -1 do
		local entry = cached_log_entries[i]
		if entry then
			render_log_entry(entry)
		end
	end
end

function render_log_entry(entry)
	local sev_names = devtools_logging.SEVERITY_NAMES
	local sev_colors = devtools_logging.SEVERITY_COLORS

	-- Time
	ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(0.5, 0.5, 0.5, 1))
	ImGui.Text(entry.real_time or "??:??:??")
	ImGui.PopStyleColor(1)
	ImGui.SameLine()

	-- Severity
	local sev_color = sev_colors[entry.severity]
	if sev_color then
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(sev_color[1] / 255, sev_color[2] / 255, sev_color[3] / 255, 1))
	end
	ImGui.Text("[" .. (sev_names[entry.severity] or "?") .. "]")
	if sev_color then
		ImGui.PopStyleColor(1)
	end
	ImGui.SameLine()

	-- Category
	local cat_color = devtools_logging.get_category_color(entry.category)
	if cat_color then
		ImGui.PushStyleColor(ImGuiCol.Text, fcolor():set(cat_color[1] / 255, cat_color[2] / 255, cat_color[3] / 255, 1))
	end
	ImGui.Text("[" .. (entry.category or "?") .. "]")
	if cat_color then
		ImGui.PopStyleColor(1)
	end
	ImGui.SameLine()

	-- Message
	ImGui.Text(entry.message or "")
end

-- ============================================================================
-- COLOR HELPERS
-- ============================================================================

local module_colors = {}
local color_index = 0

sync_module_colors = function(wrapped_modules)
	module_colors = {}
	color_index = 0
	for i, module_name in ipairs(wrapped_modules) do
		color_index = color_index + 1
		module_colors[module_name] = get_module_color_by_index(color_index)
	end
end

function get_module_color(func_name)
	local module_name = func_name:match("^([^%.]+)%.")
	if not module_name then
		return COLOR_WHITE
	end

	if not module_colors[module_name] then
		color_index = color_index + 1
		module_colors[module_name] = get_module_color_by_index(color_index)
	end

	return module_colors[module_name]
end

get_module_color_by_name = function(module_name)
	return module_colors[module_name] or COLOR_WHITE
end

function get_module_color_by_index(index)
	return MODULE_PALETTE[((index - 1) % #MODULE_PALETTE) + 1]
end

function get_timing_color(ms)
	if ms < 1 then
		return TIMING_COLOR_GREEN
	elseif ms < 5 then
		return TIMING_COLOR_YELLOW
	elseif ms < 20 then
		return TIMING_COLOR_ORANGE
	else
		return TIMING_COLOR_RED
	end
end

-- ============================================================================
-- WINDOW CONTROL API
-- ============================================================================

-- Profiler window controls
function toggle_profiler()
	show_profiler_window = not show_profiler_window
end

function show_profiler()
	show_profiler_window = true
end

function hide_profiler()
	show_profiler_window = false
end

function is_profiler_visible()
	return show_profiler_window
end

-- Logs window controls
function toggle_logs()
	show_logs_window = not show_logs_window
end

function show_logs()
	show_logs_window = true
end

function hide_logs()
	show_logs_window = false
end

function is_logs_visible()
	return show_logs_window
end

-- Legacy/convenience functions (toggle both, or just profiler)
function toggle_window()
	show_profiler_window = not show_profiler_window
end

function show()
	show_profiler_window = true
end

function hide()
	show_profiler_window = false
	show_logs_window = false
end

function is_visible()
	return show_profiler_window or show_logs_window
end

-- ============================================================================
-- IMGUI REGISTRATION
-- ============================================================================

init_ui = function()
    -- Create group (safe even if called once)
    if not ImGui.Groups.DevTools then
        ImGui.Groups.Add("DevTools")
    end

    -- Add menu bar hook (only once)
    if not _G.__DEVTOOLS_MENU_BAR_HOOKED then
        ImGui.Groups.MenuBar.Widget(function()
            if ImGui.BeginMenu("DevTools") then
                if ImGui.Groups.DevTools and ImGui.Groups.DevTools.Render then
                    ImGui.Groups.DevTools.Render()
                end
                ImGui.EndMenu()
            end
        end)
        _G.__DEVTOOLS_MENU_BAR_HOOKED = true
    end

    -- Register widgets (only once)
    if not _G.__DEVTOOLS_WIDGETS_HOOKED then
        ImGui.Groups.DevTools.Widget(function()
            local _
            _, show_profiler_window = ImGui.MenuItem("Profiler", nil, show_profiler_window, true)
            _, show_logs_window = ImGui.MenuItem("Logs", nil, show_logs_window, true)
        end)

        ImGui.Groups.Main.Widget(function()
            if show_profiler_window then
                render_profiler_window()
            end
            if show_logs_window then
                render_logs_window()
            end
        end)

		if DEVTOOLS_VERBOSE then
			printf("[DEVTOOLS] ImGui panel registered. Open via ImGui menu -> DevTools")
		end
        _G.__DEVTOOLS_WIDGETS_HOOKED = true
    end
end

-- ============================================================================
-- KEYBIND (Optional - can be customized)
-- ============================================================================

function on_key_press(key)
	-- F9 to toggle DevTools window (customizable)
	if key == DIK_keys.DIK_F9 then
		toggle_window()
	end
end

-- Register keybind
safe_register("on_key_press", on_key_press)

-- ============================================================================
-- TIMED PROFILING AUTO-STOP
-- ============================================================================

function on_actor_update()
	-- Check if timed profiling should auto-stop
	if timed_profiling_enabled and devtools_profiler and devtools_profiler.is_enabled() then
		local elapsed = (time_global() - profiling_start_time) / 1000
		if elapsed >= profiling_duration_sec then
			devtools_profiler.disable()
			timed_profiling_enabled = false
			if DEVTOOLS_VERBOSE then
				printf("[DEVTOOLS] Timed profiling auto-stopped after " .. tostring(profiling_duration_sec) .. "s")
			end
		end
	end

	-- Auto rewrap tick (optional)
	if auto_rewrap_enabled and devtools_profiler and type(devtools_profiler.is_enabled) == "function" and devtools_profiler.is_enabled() then
		local tg = time_global()
		if (tg - (last_rewrap_tg or 0)) >= (rewrap_interval_ms or 1000) then
			if type(devtools_profiler.rewrap_registered_modules) == "function" then
				devtools_profiler.rewrap_registered_modules()
			end
			last_rewrap_tg = tg
		end
	end
end
