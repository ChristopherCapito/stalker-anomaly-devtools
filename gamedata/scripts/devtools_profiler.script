--[[
=======================================================================================
    DevTools Profiler - Generic Performance Monitoring for S.T.A.L.K.E.R. Anomaly
    
    A standalone, mod-agnostic profiling system with automatic function wrapping.
    Can profile ANY Lua module without requiring code changes to the target mod.
    
    Quick Start:
        -- Profile a module (optional - can also select via UI):
        devtools_profiler.register_module("my_mod")
        
        -- Enable profiling:
        devtools_profiler.enable()
        
        -- Check stats:
        local stats = devtools_profiler.get_all_stats()
    
    Manual Timing (for custom code sections):
        devtools_profiler.start_timer("my_operation")
        -- ... code ...
        devtools_profiler.end_timer("my_operation")
=======================================================================================
--]]

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

local MAX_SAMPLES = 60          -- Rolling window size for samples
local ENABLED = true            -- Global enable/disable for timing
local DEBUG_TIMING = false      -- Enable to print timing debug info

-- ============================================================================
-- BLACKLIST CONFIGURATION
-- ============================================================================
-- Modules and functions that should never be profiled to prevent stack overflow
-- and infinite recursion. Add or remove items as needed.

local BLACKLIST_CONFIG = {
    -- DevTools modules (profiling them causes infinite recursion)
    modules = {
        "devtools_profiler",
        "devtools_logging",
        "devtools_config",
        "devtools_imgui",
    },
    
    -- Lua standard library modules (system modules that shouldn't be profiled)
    system_modules = {
        "_G",
        "os",
        "io",
        "debug",
        "string",
        "math",
        "table",
        "coroutine",
        "package",
    },
    
    -- Function names that should never be wrapped (system functions)
    functions = {
        "printf",
        "get_time",
        "time_global",
        "os",
        "io",
        "debug",
    }
}

-- Build lookup tables for fast checking
local BLACKLISTED_MODULES = {}
local BLACKLISTED_FUNCTIONS = {}

for _, name in ipairs(BLACKLIST_CONFIG.modules) do
    BLACKLISTED_MODULES[name] = true
end

for _, name in ipairs(BLACKLIST_CONFIG.system_modules) do
    BLACKLISTED_MODULES[name] = true
end

for _, name in ipairs(BLACKLIST_CONFIG.functions) do
    BLACKLISTED_FUNCTIONS[name] = true
end

-- ============================================================================
-- INTERNAL STATE
-- ============================================================================

local timer_stacks = {}         -- Per-function timer stacks: timer_stacks[name] = {start1, start2, ...}
local stats = {}                -- Statistics per function

-- Module management
local registered_modules = {}   -- Modules registered for profiling: {name = true}
local wrapped_modules = {}      -- Stores original functions per module
local wrapped_function_count = 0

-- Recursion guard to prevent infinite loops
local profiling_depth = 0       -- Current profiling depth
local MAX_PROFILING_DEPTH = 1   -- Only allow one level (prevents profiling the profiler)

-- Call stack tracking for nested call handling
local active_call_stack = {}  -- Stack of currently executing profiled functions
local MAX_CALL_DEPTH = 100     -- Maximum call depth to prevent stack overflow
local safety_stats = {         -- Safety statistics
    skipped_calls = 0,
    max_depth_reached = 0,
    blacklist_violations = 0
}

-- ============================================================================
-- HIGH-PRECISION TIMING
-- Uses profile_timer (X-Ray native) - the ONLY accurate timing method in X-Ray
-- os.clock and time_global have insufficient precision (often 0ms for fast ops)
-- ============================================================================

-- Check if profile_timer is available (required for accurate timing)
local PROFILE_TIMER_AVAILABLE = (profile_timer ~= nil)

-- Fallback timing (only used if profile_timer unavailable - not accurate!)
local function get_time()
    if time_global then
        return time_global()
    end
    if os and os.clock then
        return os.clock() * 1000
    end
    return 0
end

-- ============================================================================
-- STATISTICS MANAGEMENT
-- ============================================================================

local function init_stats(name)
    if not stats[name] then
        stats[name] = {
            call_count = 0,
            total_ms = 0,
            min_ms = math.huge,
            max_ms = 0,
            last_ms = 0,
            samples = {}
        }
    end
end

-- ============================================================================
-- MANUAL TIMING API
-- ============================================================================

-- Start timing a named operation
function start_timer(name)
    if not ENABLED then return end
    
    -- Check depth BEFORE incrementing
    if profiling_depth >= MAX_PROFILING_DEPTH then
        safety_stats.skipped_calls = safety_stats.skipped_calls + 1
        return
    end
    
    profiling_depth = profiling_depth + 1
    
    -- Initialize stack for this function if needed
    if not timer_stacks[name] then
        timer_stacks[name] = {}
    end
    
    -- Create a timer entry for this specific call
    local timer_entry = {}
    
    -- Use profile_timer (the ONLY accurate timing method in X-Ray)
    if PROFILE_TIMER_AVAILABLE then
        timer_entry.pt = profile_timer()
        timer_entry.pt:start()
    else
        -- Fallback (inaccurate - os.clock/time_global don't have enough precision)
        timer_entry.start = get_time()
    end
    
    -- Push onto the stack
    table.insert(timer_stacks[name], timer_entry)
    
    if DEBUG_TIMING and stats[name] and stats[name].call_count < 5 then
        printf("[DEVTOOLS] start_timer(%s): stack_depth=%d", name, #timer_stacks[name])
    end
end

-- End timing and record the duration
function end_timer(name)
    if not ENABLED then return 0 end
    
    -- Decrement depth (only if we actually started profiling)
    if profiling_depth > 0 then
        profiling_depth = profiling_depth - 1
    end
    
    -- Pop timer entry from the stack
    local stack = timer_stacks[name]
    if not stack or #stack == 0 then
        return 0
    end
    
    local timer_entry = table.remove(stack)  -- Pop from end of stack
    local duration_ms = 0
    
    -- Prefer profile_timer if we used it (most accurate)
    if timer_entry.pt then
        timer_entry.pt:stop()
        duration_ms = timer_entry.pt:time() / 1000  -- Convert microseconds to ms
    else
        -- Fallback to wall-clock timing
        local end_time = get_time()
        duration_ms = end_time - timer_entry.start
    end
    
    if DEBUG_TIMING and (not stats[name] or stats[name].call_count < 5) then
        printf("[DEVTOOLS] end_timer(%s): duration=%f ms, stack_depth=%d", name, duration_ms, #stack)
    end
    
    -- Update statistics
    init_stats(name)
    local s = stats[name]
    s.call_count = s.call_count + 1
    s.total_ms = s.total_ms + duration_ms
    s.last_ms = duration_ms
    
    if duration_ms < s.min_ms then s.min_ms = duration_ms end
    if duration_ms > s.max_ms then s.max_ms = duration_ms end
    
    -- Rolling sample window
    table.insert(s.samples, duration_ms)
    if #s.samples > MAX_SAMPLES then
        table.remove(s.samples, 1)
    end
    
    return duration_ms
end

-- Get elapsed time without stopping (uses top of stack)
function get_elapsed(name)
    if not ENABLED then return 0 end
    local stack = timer_stacks[name]
    if not stack or #stack == 0 then return 0 end
    local timer_entry = stack[#stack]  -- Peek at top of stack
    return get_time() - timer_entry.start
end

-- ============================================================================
-- STATISTICS API
-- ============================================================================

-- Get stats for a specific function
function get_stats(name)
    init_stats(name)
    local s = stats[name]
    
    local avg_ms = 0
    if s.call_count > 0 then
        avg_ms = s.total_ms / s.call_count
    end
    
    return {
        call_count = s.call_count,
        total_ms = s.total_ms,
        avg_ms = avg_ms,
        min_ms = s.min_ms == math.huge and 0 or s.min_ms,
        max_ms = s.max_ms,
        last_ms = s.last_ms,
        samples = s.samples
    }
end

-- Get all tracked function statistics
function get_all_stats()
    local result = {}
    for name, _ in pairs(stats) do
        result[name] = get_stats(name)
    end
    return result
end

-- Get list of tracked function names
function get_tracked_functions()
    local names = {}
    for name, _ in pairs(stats) do
        table.insert(names, name)
    end
    table.sort(names)
    return names
end

-- Reset statistics for a specific function
function reset_stats(name)
    stats[name] = nil
end

-- Reset all statistics
function reset_all()
    stats = {}
    timer_stacks = {}
end

-- Get safety statistics (skipped calls, max depth, blacklist violations)
function get_safety_stats()
    return {
        skipped_calls = safety_stats.skipped_calls,
        max_depth_reached = safety_stats.max_depth_reached,
        blacklist_violations = safety_stats.blacklist_violations,
        current_call_depth = #active_call_stack,
        current_profiling_depth = profiling_depth
    }
end

-- Reset safety statistics
function reset_safety_stats()
    safety_stats.skipped_calls = 0
    safety_stats.max_depth_reached = 0
    safety_stats.blacklist_violations = 0
end

-- ============================================================================
-- BLACKLIST HELPERS
-- ============================================================================

-- Check if a module is blacklisted
function is_module_blacklisted(module_name)
    return BLACKLISTED_MODULES[module_name] == true
end

-- Check if a function name is blacklisted
function is_function_blacklisted(function_name)
    return BLACKLISTED_FUNCTIONS[function_name] == true
end

-- Get the blacklist configuration (for inspection/modification)
function get_blacklist_config()
    return BLACKLIST_CONFIG
end

-- Add a module to the blacklist (runtime modification)
function add_blacklisted_module(module_name)
    if not module_name or module_name == "" then return false end
    BLACKLISTED_MODULES[module_name] = true
    table.insert(BLACKLIST_CONFIG.modules, module_name)
    return true
end

-- Add a function to the blacklist (runtime modification)
function add_blacklisted_function(function_name)
    if not function_name or function_name == "" then return false end
    BLACKLISTED_FUNCTIONS[function_name] = true
    table.insert(BLACKLIST_CONFIG.functions, function_name)
    return true
end

-- ============================================================================
-- MODULE DISCOVERY
-- Scans _G for all loaded Lua modules (tables with functions)
-- ============================================================================

function discover_modules()
    local modules = {}

    for name, value in pairs(_G) do
        -- Check if it's a table that contains functions (likely a module)
        if type(value) == "table" and type(name) == "string" then
            -- Skip internal Lua tables (start with _)
            -- Skip devtools_ modules (profiling them causes infinite recursion)
            -- Skip blacklisted modules
            if not name:match("^_") and 
               not name:match("^devtools_") and 
               not is_module_blacklisted(name) then
                -- Check if it has at least one function
                local has_functions = false
                for _, v in pairs(value) do
                    if type(v) == "function" then
                        has_functions = true
                        break
                    end
                end

                if has_functions then
                    table.insert(modules, name)
                end
            end
        end
    end

    table.sort(modules)
    return modules
end

-- ============================================================================
-- MODULE REGISTRATION API
-- ============================================================================

-- Register a module for profiling
function register_module(module_name)
    if registered_modules[module_name] then
        return false  -- Already registered
    end
    
    -- Check blacklist
    if is_module_blacklisted(module_name) then
        printf("[DEVTOOLS] Cannot register blacklisted module: %s", module_name)
        return false
    end
    
    registered_modules[module_name] = true
    printf("[DEVTOOLS] Registered module for profiling: %s", module_name)
    return true
end

-- Unregister a module
function unregister_module(module_name)
    if not registered_modules[module_name] then
        return false
    end
    
    -- If currently wrapped, unwrap first
    if wrapped_modules[module_name] then
        local module_table = _G[module_name]
        if module_table then
            unwrap_module(module_name, module_table)
        end
    end
    
    registered_modules[module_name] = nil
    printf("[DEVTOOLS] Unregistered module: %s", module_name)
    return true
end

-- Get list of registered modules
function get_registered_modules()
    local result = {}
    for name, _ in pairs(registered_modules) do
        table.insert(result, name)
    end
    table.sort(result)
    return result
end

-- Check if a module is registered
function is_module_registered(module_name)
    return registered_modules[module_name] == true
end

-- ============================================================================
-- AUTO-PROFILING (Monkey-patching)
-- ============================================================================

local auto_profile_enabled = false

-- Wrap a single function with timing
local function wrap_function(module_name, func_name, original_func)
    return function(...)
        local full_name = module_name .. "." .. func_name
        
        -- Runtime blacklist check (fail-safe)
        if is_function_blacklisted(func_name) or is_module_blacklisted(module_name) then
            safety_stats.blacklist_violations = safety_stats.blacklist_violations + 1
            return original_func(...)
        end
        
        -- Check call depth
        if #active_call_stack >= MAX_CALL_DEPTH then
            safety_stats.max_depth_reached = math.max(safety_stats.max_depth_reached, #active_call_stack)
            return original_func(...)
        end
        
        -- Push to call stack (for depth tracking)
        table.insert(active_call_stack, full_name)
        
        -- Start timing
        start_timer(full_name)
        
        -- Execute function directly (let errors propagate naturally)
        -- Use xpcall pattern to ensure end_timer is called even on error
        local results = {pcall(original_func, ...)}
        local success = results[1]
        
        end_timer(full_name)
        
        -- Pop from call stack
        table.remove(active_call_stack)
        
        if not success then
            -- Function failed - re-throw error (results[2] is the error)
            error(results[2])
        end
        
        -- Return all values (skip the success flag at index 1)
        return unpack(results, 2)
    end
end

-- Wrap all functions in a module
function wrap_module(module_name, module_table)
    if not module_table then
        printf("[DEVTOOLS] Cannot wrap module '%s' - not found", module_name)
        return 0
    end
    
    if wrapped_modules[module_name] then
        return 0  -- Already wrapped
    end
    
    local originals = {}
    local count = 0
    
    for name, value in pairs(module_table) do
        if type(value) == "function" then
            -- Skip blacklisted functions that could cause recursion
            if is_function_blacklisted(name) then
                -- Skip this function
            else
                originals[name] = value
                module_table[name] = wrap_function(module_name, name, value)
                count = count + 1
            end
        end
    end
    
    wrapped_modules[module_name] = originals
    wrapped_function_count = wrapped_function_count + count
    
    printf("[DEVTOOLS] Wrapped %d functions in '%s'", count, module_name)
    return count
end

-- Unwrap a module (restore original functions)
function unwrap_module(module_name, module_table)
    if not module_table then return 0 end
    
    local originals = wrapped_modules[module_name]
    if not originals then return 0 end
    
    local count = 0
    for name, func in pairs(originals) do
        module_table[name] = func
        count = count + 1
    end
    
    wrapped_function_count = wrapped_function_count - count
    wrapped_modules[module_name] = nil
    
    printf("[DEVTOOLS] Unwrapped %d functions in '%s'", count, module_name)
    return count
end

-- Enable auto-profiling for all registered modules
function enable()
    if auto_profile_enabled then
        printf("[DEVTOOLS] Auto-profiling already enabled")
        return
    end
    
    printf("[DEVTOOLS] Enabling auto-profiling...")
    local total = 0
    
    for module_name, _ in pairs(registered_modules) do
        local module_table = _G[module_name]
        if module_table then
            total = total + wrap_module(module_name, module_table)
        else
            printf("[DEVTOOLS] Module '%s' not found in _G", module_name)
        end
    end
    
    auto_profile_enabled = true
    printf("[DEVTOOLS] Auto-profiling ENABLED - wrapped %d functions", total)
end

-- Disable auto-profiling and restore original functions
function disable()
    if not auto_profile_enabled then
        printf("[DEVTOOLS] Auto-profiling already disabled")
        return
    end
    
    printf("[DEVTOOLS] Disabling auto-profiling...")
    
    -- Unwrap all wrapped modules
    for module_name, _ in pairs(wrapped_modules) do
        local module_table = _G[module_name]
        if module_table then
            unwrap_module(module_name, module_table)
        end
    end
    
    auto_profile_enabled = false
    printf("[DEVTOOLS] Auto-profiling DISABLED")
end

-- Check if auto-profiling is enabled
function is_enabled()
    return auto_profile_enabled
end

-- ============================================================================
-- WRAPPED MODULE INFO
-- ============================================================================

-- Get list of currently wrapped modules
function get_wrapped_modules()
    local result = {}
    for name, _ in pairs(wrapped_modules) do
        table.insert(result, name)
    end
    table.sort(result)
    return result
end

-- Get count of wrapped functions
function get_wrapped_function_count()
    return wrapped_function_count
end

-- Check if a module is currently wrapped
function is_module_wrapped(module_name)
    return wrapped_modules[module_name] ~= nil
end

-- ============================================================================
-- PRESETS API (via devtools_config)
-- ============================================================================

-- Save current selection as a preset
function save_preset(name)
    if devtools_config then
        local modules = get_registered_modules()
        return devtools_config.save_preset(name, modules)
    end
    return false
end

-- Load a preset and register those modules
function load_preset(name)
    if devtools_config then
        local modules = devtools_config.load_preset(name)
        if modules then
            -- Clear current selection
            for _, mod_name in ipairs(get_registered_modules()) do
                unregister_module(mod_name)
            end
            -- Register preset modules
            for _, mod_name in ipairs(modules) do
                register_module(mod_name)
            end
            return true
        end
    end
    return false
end

-- Delete a preset
function delete_preset(name)
    if devtools_config then
        return devtools_config.delete_preset(name)
    end
    return false
end

-- Get all preset names
function get_preset_names()
    if devtools_config then
        return devtools_config.get_preset_names()
    end
    return {}
end

-- Check if preset exists
function preset_exists(name)
    if devtools_config then
        return devtools_config.preset_exists(name)
    end
    return false
end

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

function set_enabled(enabled)
    ENABLED = enabled
end

function get_max_samples()
    return MAX_SAMPLES
end

function set_max_samples(count)
    MAX_SAMPLES = count
end

function set_debug(enabled)
    DEBUG_TIMING = enabled
    if enabled then
        printf("[DEVTOOLS] Debug timing ENABLED")
    else
        printf("[DEVTOOLS] Debug timing DISABLED")
    end
end

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

function copy_table(t)
    if type(t) ~= "table" then return t end
    local result = {}
    for k, v in pairs(t) do
        if type(v) == "table" then
            result[k] = copy_table(v)
        else
            result[k] = v
        end
    end
    return result
end

function format_ms(ms)
    if ms < 1 then
        return string.format("%.2f", ms)
    elseif ms < 10 then
        return string.format("%.1f", ms)
    else
        return string.format("%.0f", ms)
    end
end

-- Check available timing method
function check_timing_method()
    local method = "unknown"
    local precision = "unknown"
    
    if os and os.clock then
        method = "os.clock"
        precision = "sub-millisecond (platform-dependent)"
        
        local start = os.clock()
        local sum = 0
        for i = 1, 1000 do sum = sum + i end
        local finish = os.clock()
        printf("[DEVTOOLS] os.clock test: 1000 additions = %.1f microseconds", (finish - start) * 1000000)
    elseif time_global then
        method = "time_global"
        precision = "milliseconds (integer)"
        printf("[DEVTOOLS] WARNING: Using time_global - sub-ms ops will show as 0")
    else
        method = "none"
        precision = "none"
        printf("[DEVTOOLS] ERROR: No timing method available!")
    end
    
    printf("[DEVTOOLS] Timing method: %s", method)
    printf("[DEVTOOLS] Precision: %s", precision)
    
    return method, precision
end

-- Print stats summary to console
function print_summary()
    printf("=== DevTools Profiler Summary ===")
    
    local names = get_tracked_functions()
    if #names == 0 then
        printf("  (no data collected)")
    else
        for _, name in ipairs(names) do
            local s = get_stats(name)
            printf("  %s: calls=%d avg=%.2fms min=%.2fms max=%.2fms",
                name, s.call_count, s.avg_ms, s.min_ms, s.max_ms)
        end
    end
    
    printf("=================================")
end

-- ============================================================================
-- CSV EXPORT
-- ============================================================================

-- Escape CSV field (handles commas, quotes, newlines)
local function escape_csv_field(field)
    local str = tostring(field)
    -- If field contains comma, quote, or newline, wrap in quotes and escape quotes
    if string.find(str, "[,\"\n\r]") then
        str = string.gsub(str, "\"", "\"\"")  -- Escape quotes by doubling them
        return "\"" .. str .. "\""
    end
    return str
end

-- Export all statistics to CSV file
function export_to_csv(filepath)
    local all_stats = get_all_stats()
    local names = get_tracked_functions()
    
    if #names == 0 then
        printf("[DEVTOOLS] No statistics to export")
        return false
    end
    
    -- Determine file path
    local path = filepath
    if not path or path == "" then
        local appdata = getFS():update_path("$app_data_root$", "")
        if appdata and appdata ~= "" then
            path = appdata .. "devtools_profiler_export.csv"
        else
            path = getFS():update_path("$logs$", "") .. "devtools_profiler_export.csv"
        end
    end
    
    -- Open file for writing
    local file = io.open(path, "w")
    if not file then
        printf("[DEVTOOLS] Failed to open file for CSV export: %s", path)
        return false
    end
    
    -- Write CSV header
    file:write("Function,Call Count,Avg (ms),Min (ms),Max (ms),Total (ms),Last (ms)\n")
    
    -- Sort by total time (descending) for easier analysis
    table.sort(names, function(a, b)
        local stats_a = all_stats[a]
        local stats_b = all_stats[b]
        if stats_a and stats_b then
            return stats_a.total_ms > stats_b.total_ms
        end
        return a < b
    end)
    
    -- Write data rows
    for _, name in ipairs(names) do
        local s = all_stats[name]
        if s then
            file:write(string.format("%s,%d,%.6f,%.6f,%.6f,%.6f,%.6f\n",
                escape_csv_field(name),
                s.call_count,
                s.avg_ms,
                s.min_ms == math.huge and 0 or s.min_ms,
                s.max_ms,
                s.total_ms,
                s.last_ms
            ))
        end
    end
    
    file:close()
    printf("[DEVTOOLS] CSV export saved to: %s (%d functions)", path, #names)
    return true, path
end

-- Get default CSV export path
function get_csv_export_path()
    local appdata = getFS():update_path("$app_data_root$", "")
    if appdata and appdata ~= "" then
        return appdata .. "devtools_profiler_export.csv"
    else
        return getFS():update_path("$logs$", "") .. "devtools_profiler_export.csv"
    end
end

-- ============================================================================
-- INITIALIZATION
-- ============================================================================

function on_game_start()
    printf("[DEVTOOLS] Profiler initialized")
    
    -- Check timing method availability
    if PROFILE_TIMER_AVAILABLE then
        printf("[DEVTOOLS] Using profile_timer for accurate microsecond timing")
    else
        printf("[DEVTOOLS] WARNING: profile_timer not available! Timing will be inaccurate.")
    end
end

-- Register callback
if RegisterScriptCallback then
    RegisterScriptCallback("on_game_start", on_game_start)
end
