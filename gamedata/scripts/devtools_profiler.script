--[[
=======================================================================================
    DevTools Profiler - Generic Performance Monitoring for S.T.A.L.K.E.R. Anomaly
    
    A standalone, mod-agnostic profiling system with automatic function wrapping.
    Can profile ANY Lua module without requiring code changes to the target mod.
    
    Quick Start:
        -- Profile a module (optional - can also select via UI):
        devtools_profiler.register_module("my_mod")
        
        -- Enable profiling:
        devtools_profiler.enable()
        
        -- Check stats:
        local stats = devtools_profiler.get_all_stats()
    
    Manual Timing (for custom code sections):
        devtools_profiler.start_timer("my_operation")
        -- ... code ...
        devtools_profiler.end_timer("my_operation")
=======================================================================================
--]]

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

local MAX_SAMPLES = 60          -- Rolling window size for samples
local ENABLED = true            -- Global enable/disable for timing
local DEBUG_TIMING = false      -- Enable to print timing debug info

-- ============================================================================
-- INTERNAL STATE
-- ============================================================================

local timers = {}               -- Active timers: timers[name] = start_time
local stats = {}                -- Statistics per function
local profile_timers = {}       -- X-Ray profile_timer objects per function

-- Module management
local registered_modules = {}   -- Modules registered for profiling: {name = true}
local wrapped_modules = {}      -- Stores original functions per module
local wrapped_function_count = 0

-- ============================================================================
-- HIGH-PRECISION TIMING
-- Priority: profile_timer (X-Ray C++) > os.clock > time_global
-- ============================================================================

local function get_time()
    -- os.clock() gives CPU time with sub-millisecond precision
    if os and os.clock then
        return os.clock() * 1000  -- Convert to milliseconds
    end
    -- Fallback to time_global (integer milliseconds - low precision)
    return time_global()
end

-- ============================================================================
-- STATISTICS MANAGEMENT
-- ============================================================================

local function init_stats(name)
    if not stats[name] then
        stats[name] = {
            call_count = 0,
            total_ms = 0,
            min_ms = math.huge,
            max_ms = 0,
            last_ms = 0,
            samples = {}
        }
    end
end

-- ============================================================================
-- MANUAL TIMING API
-- ============================================================================

-- Start timing a named operation
function start_timer(name)
    if not ENABLED then return end
    
    -- Try to use profile_timer if available (X-Ray high-res timer)
    if profile_timer and not profile_timers[name] then
        profile_timers[name] = profile_timer()
    end
    
    if profile_timers[name] then
        profile_timers[name]:start()
    end
    
    timers[name] = get_time()
    
    if DEBUG_TIMING and stats[name] and stats[name].call_count < 5 then
        printf("[DEVTOOLS] start_timer(%s): time=%f", name, timers[name])
    end
end

-- End timing and record the duration
function end_timer(name)
    if not ENABLED then return 0 end
    
    local duration_ms = 0
    
    -- Try profile_timer first (microsecond precision)
    if profile_timers[name] then
        profile_timers[name]:stop()
        duration_ms = profile_timers[name]:time() / 1000  -- Convert to ms
        
        if DEBUG_TIMING and (not stats[name] or stats[name].call_count < 5) then
            printf("[DEVTOOLS] end_timer(%s): profile_timer=%f ms", name, duration_ms)
        end
    else
        local start_time = timers[name]
        if not start_time then
            return 0
        end
        
        local end_time = get_time()
        duration_ms = end_time - start_time
        
        if DEBUG_TIMING and (not stats[name] or stats[name].call_count < 5) then
            printf("[DEVTOOLS] end_timer(%s): duration=%f ms", name, duration_ms)
        end
    end
    
    -- Update statistics
    init_stats(name)
    local s = stats[name]
    s.call_count = s.call_count + 1
    s.total_ms = s.total_ms + duration_ms
    s.last_ms = duration_ms
    
    if duration_ms < s.min_ms then s.min_ms = duration_ms end
    if duration_ms > s.max_ms then s.max_ms = duration_ms end
    
    -- Rolling sample window
    table.insert(s.samples, duration_ms)
    if #s.samples > MAX_SAMPLES then
        table.remove(s.samples, 1)
    end
    
    timers[name] = nil
    return duration_ms
end

-- Get elapsed time without stopping
function get_elapsed(name)
    if not ENABLED then return 0 end
    local start_time = timers[name]
    if not start_time then return 0 end
    return get_time() - start_time
end

-- ============================================================================
-- STATISTICS API
-- ============================================================================

-- Get stats for a specific function
function get_stats(name)
    init_stats(name)
    local s = stats[name]
    
    local avg_ms = 0
    if s.call_count > 0 then
        avg_ms = s.total_ms / s.call_count
    end
    
    return {
        call_count = s.call_count,
        total_ms = s.total_ms,
        avg_ms = avg_ms,
        min_ms = s.min_ms == math.huge and 0 or s.min_ms,
        max_ms = s.max_ms,
        last_ms = s.last_ms,
        samples = s.samples
    }
end

-- Get all tracked function statistics
function get_all_stats()
    local result = {}
    for name, _ in pairs(stats) do
        result[name] = get_stats(name)
    end
    return result
end

-- Get list of tracked function names
function get_tracked_functions()
    local names = {}
    for name, _ in pairs(stats) do
        table.insert(names, name)
    end
    table.sort(names)
    return names
end

-- Reset statistics for a specific function
function reset_stats(name)
    stats[name] = nil
end

-- Reset all statistics
function reset_all()
    stats = {}
    timers = {}
end

-- ============================================================================
-- MODULE DISCOVERY
-- Scans _G for all loaded Lua modules (tables with functions)
-- ============================================================================

function discover_modules()
    local modules = {}

    for name, value in pairs(_G) do
        -- Check if it's a table that contains functions (likely a module)
        if type(value) == "table" and type(name) == "string" then
            -- Skip internal Lua tables (start with _)
            -- Skip devtools_ modules (profiling them causes infinite recursion)
            if not name:match("^_") and not name:match("^devtools_") then
                -- Check if it has at least one function
                local has_functions = false
                for _, v in pairs(value) do
                    if type(v) == "function" then
                        has_functions = true
                        break
                    end
                end

                if has_functions then
                    table.insert(modules, name)
                end
            end
        end
    end

    table.sort(modules)
    return modules
end

-- ============================================================================
-- MODULE REGISTRATION API
-- ============================================================================

-- Register a module for profiling
function register_module(module_name)
    if registered_modules[module_name] then
        return false  -- Already registered
    end
    
    registered_modules[module_name] = true
    printf("[DEVTOOLS] Registered module for profiling: %s", module_name)
    return true
end

-- Unregister a module
function unregister_module(module_name)
    if not registered_modules[module_name] then
        return false
    end
    
    -- If currently wrapped, unwrap first
    if wrapped_modules[module_name] then
        local module_table = _G[module_name]
        if module_table then
            unwrap_module(module_name, module_table)
        end
    end
    
    registered_modules[module_name] = nil
    printf("[DEVTOOLS] Unregistered module: %s", module_name)
    return true
end

-- Get list of registered modules
function get_registered_modules()
    local result = {}
    for name, _ in pairs(registered_modules) do
        table.insert(result, name)
    end
    table.sort(result)
    return result
end

-- Check if a module is registered
function is_module_registered(module_name)
    return registered_modules[module_name] == true
end

-- ============================================================================
-- AUTO-PROFILING (Monkey-patching)
-- ============================================================================

local auto_profile_enabled = false

-- Wrap a single function with timing
local function wrap_function(module_name, func_name, original_func)
    return function(...)
        start_timer(module_name .. "." .. func_name)
        local results = {original_func(...)}
        end_timer(module_name .. "." .. func_name)
        return unpack(results)
    end
end

-- Wrap all functions in a module
function wrap_module(module_name, module_table)
    if not module_table then
        printf("[DEVTOOLS] Cannot wrap module '%s' - not found", module_name)
        return 0
    end
    
    if wrapped_modules[module_name] then
        return 0  -- Already wrapped
    end
    
    local originals = {}
    local count = 0
    
    for name, value in pairs(module_table) do
        if type(value) == "function" then
            originals[name] = value
            module_table[name] = wrap_function(module_name, name, value)
            count = count + 1
        end
    end
    
    wrapped_modules[module_name] = originals
    wrapped_function_count = wrapped_function_count + count
    
    printf("[DEVTOOLS] Wrapped %d functions in '%s'", count, module_name)
    return count
end

-- Unwrap a module (restore original functions)
function unwrap_module(module_name, module_table)
    if not module_table then return 0 end
    
    local originals = wrapped_modules[module_name]
    if not originals then return 0 end
    
    local count = 0
    for name, func in pairs(originals) do
        module_table[name] = func
        count = count + 1
    end
    
    wrapped_function_count = wrapped_function_count - count
    wrapped_modules[module_name] = nil
    
    printf("[DEVTOOLS] Unwrapped %d functions in '%s'", count, module_name)
    return count
end

-- Enable auto-profiling for all registered modules
function enable()
    if auto_profile_enabled then
        printf("[DEVTOOLS] Auto-profiling already enabled")
        return
    end
    
    printf("[DEVTOOLS] Enabling auto-profiling...")
    local total = 0
    
    for module_name, _ in pairs(registered_modules) do
        local module_table = _G[module_name]
        if module_table then
            total = total + wrap_module(module_name, module_table)
        else
            printf("[DEVTOOLS] Module '%s' not found in _G", module_name)
        end
    end
    
    auto_profile_enabled = true
    printf("[DEVTOOLS] Auto-profiling ENABLED - wrapped %d functions", total)
end

-- Disable auto-profiling and restore original functions
function disable()
    if not auto_profile_enabled then
        printf("[DEVTOOLS] Auto-profiling already disabled")
        return
    end
    
    printf("[DEVTOOLS] Disabling auto-profiling...")
    
    -- Unwrap all wrapped modules
    for module_name, _ in pairs(wrapped_modules) do
        local module_table = _G[module_name]
        if module_table then
            unwrap_module(module_name, module_table)
        end
    end
    
    auto_profile_enabled = false
    printf("[DEVTOOLS] Auto-profiling DISABLED")
end

-- Check if auto-profiling is enabled
function is_enabled()
    return auto_profile_enabled
end

-- ============================================================================
-- WRAPPED MODULE INFO
-- ============================================================================

-- Get list of currently wrapped modules
function get_wrapped_modules()
    local result = {}
    for name, _ in pairs(wrapped_modules) do
        table.insert(result, name)
    end
    table.sort(result)
    return result
end

-- Get count of wrapped functions
function get_wrapped_function_count()
    return wrapped_function_count
end

-- Check if a module is currently wrapped
function is_module_wrapped(module_name)
    return wrapped_modules[module_name] ~= nil
end

-- ============================================================================
-- PRESETS API (via devtools_config)
-- ============================================================================

-- Save current selection as a preset
function save_preset(name)
    if devtools_config then
        local modules = get_registered_modules()
        return devtools_config.save_preset(name, modules)
    end
    return false
end

-- Load a preset and register those modules
function load_preset(name)
    if devtools_config then
        local modules = devtools_config.load_preset(name)
        if modules then
            -- Clear current selection
            for _, mod_name in ipairs(get_registered_modules()) do
                unregister_module(mod_name)
            end
            -- Register preset modules
            for _, mod_name in ipairs(modules) do
                register_module(mod_name)
            end
            return true
        end
    end
    return false
end

-- Delete a preset
function delete_preset(name)
    if devtools_config then
        return devtools_config.delete_preset(name)
    end
    return false
end

-- Get all preset names
function get_preset_names()
    if devtools_config then
        return devtools_config.get_preset_names()
    end
    return {}
end

-- Check if preset exists
function preset_exists(name)
    if devtools_config then
        return devtools_config.preset_exists(name)
    end
    return false
end

-- ============================================================================
-- CONFIGURATION
-- ============================================================================

function set_enabled(enabled)
    ENABLED = enabled
end

function get_max_samples()
    return MAX_SAMPLES
end

function set_max_samples(count)
    MAX_SAMPLES = count
end

function set_debug(enabled)
    DEBUG_TIMING = enabled
    if enabled then
        printf("[DEVTOOLS] Debug timing ENABLED")
    else
        printf("[DEVTOOLS] Debug timing DISABLED")
    end
end

-- ============================================================================
-- UTILITY FUNCTIONS
-- ============================================================================

function copy_table(t)
    if type(t) ~= "table" then return t end
    local result = {}
    for k, v in pairs(t) do
        if type(v) == "table" then
            result[k] = copy_table(v)
        else
            result[k] = v
        end
    end
    return result
end

function format_ms(ms)
    if ms < 1 then
        return string.format("%.2f", ms)
    elseif ms < 10 then
        return string.format("%.1f", ms)
    else
        return string.format("%.0f", ms)
    end
end

-- Check available timing method
function check_timing_method()
    local method = "unknown"
    local precision = "unknown"
    
    if profile_timer then
        method = "profile_timer (X-Ray C++)"
        precision = "microseconds"
        
        local pt = profile_timer()
        pt:start()
        local sum = 0
        for i = 1, 1000 do sum = sum + i end
        pt:stop()
        printf("[DEVTOOLS] profile_timer test: 1000 additions = %d microseconds", pt:time())
    elseif os and os.clock then
        method = "os.clock"
        precision = "platform-dependent (usually microseconds)"
        
        local start = os.clock()
        local sum = 0
        for i = 1, 1000 do sum = sum + i end
        local finish = os.clock()
        printf("[DEVTOOLS] os.clock test: 1000 additions = %.1f microseconds", (finish - start) * 1000000)
    else
        method = "time_global"
        precision = "milliseconds (integer)"
        printf("[DEVTOOLS] WARNING: Using time_global - sub-ms ops will show as 0")
    end
    
    printf("[DEVTOOLS] Timing method: %s", method)
    printf("[DEVTOOLS] Precision: %s", precision)
    
    return method, precision
end

-- Print stats summary to console
function print_summary()
    printf("=== DevTools Profiler Summary ===")
    
    local names = get_tracked_functions()
    if #names == 0 then
        printf("  (no data collected)")
    else
        for _, name in ipairs(names) do
            local s = get_stats(name)
            printf("  %s: calls=%d avg=%.2fms min=%.2fms max=%.2fms",
                name, s.call_count, s.avg_ms, s.min_ms, s.max_ms)
        end
    end
    
    printf("=================================")
end

-- ============================================================================
-- CSV EXPORT
-- ============================================================================

-- Escape CSV field (handles commas, quotes, newlines)
local function escape_csv_field(field)
    local str = tostring(field)
    -- If field contains comma, quote, or newline, wrap in quotes and escape quotes
    if string.find(str, "[,\"\n\r]") then
        str = string.gsub(str, "\"", "\"\"")  -- Escape quotes by doubling them
        return "\"" .. str .. "\""
    end
    return str
end

-- Export all statistics to CSV file
function export_to_csv(filepath)
    local all_stats = get_all_stats()
    local names = get_tracked_functions()
    
    if #names == 0 then
        printf("[DEVTOOLS] No statistics to export")
        return false
    end
    
    -- Determine file path
    local path = filepath
    if not path or path == "" then
        local appdata = getFS():update_path("$app_data_root$", "")
        if appdata and appdata ~= "" then
            path = appdata .. "devtools_profiler_export.csv"
        else
            path = getFS():update_path("$logs$", "") .. "devtools_profiler_export.csv"
        end
    end
    
    -- Open file for writing
    local file = io.open(path, "w")
    if not file then
        printf("[DEVTOOLS] Failed to open file for CSV export: %s", path)
        return false
    end
    
    -- Write CSV header
    file:write("Function,Call Count,Avg (ms),Min (ms),Max (ms),Total (ms),Last (ms)\n")
    
    -- Sort by total time (descending) for easier analysis
    table.sort(names, function(a, b)
        local stats_a = all_stats[a]
        local stats_b = all_stats[b]
        if stats_a and stats_b then
            return stats_a.total_ms > stats_b.total_ms
        end
        return a < b
    end)
    
    -- Write data rows
    for _, name in ipairs(names) do
        local s = all_stats[name]
        if s then
            file:write(string.format("%s,%d,%.6f,%.6f,%.6f,%.6f,%.6f\n",
                escape_csv_field(name),
                s.call_count,
                s.avg_ms,
                s.min_ms == math.huge and 0 or s.min_ms,
                s.max_ms,
                s.total_ms,
                s.last_ms
            ))
        end
    end
    
    file:close()
    printf("[DEVTOOLS] CSV export saved to: %s (%d functions)", path, #names)
    return true, path
end

-- Get default CSV export path
function get_csv_export_path()
    local appdata = getFS():update_path("$app_data_root$", "")
    if appdata and appdata ~= "" then
        return appdata .. "devtools_profiler_export.csv"
    else
        return getFS():update_path("$logs$", "") .. "devtools_profiler_export.csv"
    end
end

-- ============================================================================
-- INITIALIZATION
-- ============================================================================

function on_game_start()
    printf("[DEVTOOLS] Profiler initialized")
end

-- Register callback
if RegisterScriptCallback then
    RegisterScriptCallback("on_game_start", on_game_start)
end
